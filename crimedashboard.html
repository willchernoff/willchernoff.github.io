<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>New Orleans Crime Incident Map</title>
    <!-- PERFORMANCE IMPROVEMENT: Pre-connect to external domains -->
    <link rel="preconnect" href="https://unpkg.com">
    <link rel="preconnect" href="https://cdn.tailwindcss.com">
    <link rel="preconnect" href="https://docs.google.com">
    <link rel="preconnect" href="https://raw.githubusercontent.com">

    <!-- Tailwind CSS CDN for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'primary-blue': '#1e3a8a', // Dark Blue
                        'secondary-blue': '#3b82f6', // Medium Blue
                        'light-blue': '#bfdbfe', // Very Light Blue
                    },
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    }
                }
            }
        }
    </script>
    <!-- Leaflet CSS for Map -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
        crossorigin=""/>
    <style>
        /* Custom styles to ensure the map container fills the space */
        #map {
            height: calc(100vh - 80px); /* Full viewport height minus header height */
            width: 100%;
            border-radius: 0.5rem; /* Rounded corners for the map */
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
        }
        body {
            background-color: #f3f4f6; /* Light gray background */
        }
    </style>
</head>
<body class="font-sans">

    <div class="min-h-screen flex flex-col p-4 sm:p-6 bg-gray-50">
        <!-- Dashboard Header -->
        <header class="mb-6 p-4 bg-white shadow-lg rounded-xl flex flex-col sm:flex-row justify-between items-center h-20">
            <h1 class="text-2xl font-extrabold text-primary-blue">
                New Orleans Crime Incident Map
            </h1>
            <div id="status-message" class="text-sm font-medium text-secondary-blue mt-2 sm:mt-0">
                Checking required libraries...
            </div>
        </header>

        <!-- Map Container -->
        <main class="flex-grow">
            <div id="map"></div>
        </main>
    </div>

    <!-- Leaflet JS (MUST be loaded before the app script) -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
        integrity="sha256-20n6a9T2EjuAo32B4FCAvL/T7/N47K5b+Wp4yM4X+xL="
        crossorigin=""></script>
    
    <script>
        // --- CONSTANTS ---
        const CRIME_DATA_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vTO3YV2swKr9zJrrA17F9dBt2OJD7cd1EFSJzQ_3IJXw3aQ0PtdCQ6t23COFOYy4ouY34g_EDjTXdaI/pub?output=csv';
        const GEOJSON_URL = 'https://raw.githubusercontent.com/piggjf/geojson_and_more/master/gn-new-orleans.geojson';
        const DEFAULT_CENTER = [29.9511, -90.0715]; // New Orleans, LA
        const CSV_CHUNK_SIZE = 5000; // Number of rows to process before yielding to the browser

        let map;
        const statusMessage = document.getElementById('status-message');

        /**
         * Initializes the Leaflet map in the 'map' container.
         */
        function initMap() {
            // Initialize map centered on New Orleans
            map = L.map('map').setView(DEFAULT_CENTER, 12);

            // Add a base tile layer (OpenStreetMap)
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="http://osm.org/copyright">OpenStreetMap</a> contributors'
            }).addTo(map);

            console.log("Map initialized.");
        }

        /**
         * Processes CSV lines in non-blocking chunks to prevent UI freeze.
         * This function calls itself recursively using setTimeout to yield control to the main thread.
         */
        function parseLinesInChunks(rows, resolve, headerIndices, chunkSize, startIndex, results) {
            const totalRows = rows.length;
            let endIndex = Math.min(startIndex + chunkSize, totalRows);

            const { latIndex, lngIndex, typeIndex, districtIndex } = headerIndices;

            // Process the current chunk synchronously
            for (let i = startIndex; i < endIndex; i++) {
                const values = rows[i].split(',');
                const lat = parseFloat(values[latIndex]);
                const lng = parseFloat(values[lngIndex]);
                
                // Get crime details, defaulting to 'Unknown' if column is missing or empty
                const crimeType = values[typeIndex] ? values[typeIndex].trim() : 'Unknown Crime';
                const district = values[districtIndex] ? values[districtIndex].trim() : 'Unknown District';

                if (!isNaN(lat) && !isNaN(lng)) {
                    results.push({ lat, lng, crimeType, district });
                }
            }

            // Update status message with progress
            const percent = Math.round((endIndex / totalRows) * 100);
            statusMessage.textContent = `Parsing crime data: ${percent}% complete (${endIndex}/${totalRows} incidents processed)...`;

            if (endIndex < totalRows) {
                // More to process, schedule the next chunk
                setTimeout(() => {
                    parseLinesInChunks(rows, resolve, headerIndices, chunkSize, endIndex, results);
                }, 10); // Yield for 10ms
            } else {
                // Done parsing all rows
                console.log(`Successfully parsed ${results.length} valid crime data points.`);
                resolve(results);
            }
        }

        /**
         * Fetches the crime data and initiates asynchronous parsing.
         * @returns {Promise<Array<Object>>} A promise that resolves to an array of incident objects.
         */
        async function fetchCrimeData() {
            try {
                statusMessage.textContent = "Fetching CSV data from Google Sheets...";
                const response = await fetch(CRIME_DATA_URL);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const csvText = await response.text();

                const lines = csvText.trim().split('\n');
                if (lines.length < 2) {
                    console.warn("CSV contained no data rows.");
                    return [];
                }

                // Header setup
                const header = lines[0].split(',').map(h => h.trim());
                const headerIndices = {
                    latIndex: header.indexOf('Latitude'),
                    lngIndex: header.indexOf('Longitude'),
                    typeIndex: header.indexOf('Crime Type'),
                    districtIndex: header.indexOf('District'),
                };

                if (headerIndices.latIndex === -1 || headerIndices.lngIndex === -1) {
                    throw new Error("CSV structure mismatch. 'Latitude' or 'Longitude' column not found.");
                }

                // Return a promise that resolves when chunked parsing is complete
                return new Promise(resolve => {
                    parseLinesInChunks(lines.slice(1), resolve, headerIndices, CSV_CHUNK_SIZE, 0, []);
                });

            } catch (error) {
                console.error("Error fetching or starting crime data parse:", error);
                return [];
            }
        }

        /**
         * Fetches and adds the New Orleans GeoJSON boundary to the map.
         */
        async function addGeoJsonBoundary() {
            try {
                const response = await fetch(GEOJSON_URL);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const geoJsonData = await response.json();

                L.geoJSON(geoJsonData, {
                    style: function (feature) {
                        return {
                            color: '#00BFFF',
                            weight: 3,
                            opacity: 0.8,
                            fillColor: '#87CEFA',
                            fillOpacity: 0.1
                        };
                    },
                    onEachFeature: function (feature, layer) {
                        if (feature.properties && feature.properties.name) {
                            layer.bindPopup(`<b>Geo Area:</b> ${feature.properties.name}`);
                        }
                    }
                }).addTo(map);

                console.log("GeoJSON boundary added.");

            } catch (error) {
                console.error("Error fetching GeoJSON data:", error);
            }
        }

        /**
         * Adds a circle marker layer for each incident to the map.
         * @param {Array<Object>} data - Array of incident objects {lat, lng, crimeType, district}
         */
        function addMarkerLayer(data) {
            if (data.length === 0) {
                statusMessage.textContent = "Data loaded, but no valid points found for mapping.";
                return;
            }

            statusMessage.textContent = "Plotting incident markers...";

            // Use a LayerGroup to efficiently add all markers at once
            const markers = L.layerGroup();
            data.forEach(incident => {
                const popupContent = `
                    <span class="font-bold text-primary-blue">${incident.crimeType}</span><br>
                    District: ${incident.district}
                `;

                L.circleMarker([incident.lat, incident.lng], {
                    radius: 4,
                    color: 'white',
                    weight: 1,
                    fillColor: '#1e3a8a', // primary-blue
                    fillOpacity: 0.7
                })
                .bindPopup(popupContent)
                .addTo(markers);
            });

            markers.addTo(map);

            statusMessage.textContent = `Dashboard Ready. Displaying ${data.length} crime incidents as markers.`;
            console.log("Marker layer added.");
        }

        /**
         * Wait until Leaflet core library is loaded, then start dashboard.
         */
        async function waitForDependencies() {
            statusMessage.textContent = "Checking required libraries...";
            // Check for Leaflet core library
            if (typeof L === 'undefined' || typeof L.map !== 'function') {
                console.warn("Leaflet core library not yet fully loaded. Retrying in 100ms...");
                // Keep trying until L is available.
                setTimeout(waitForDependencies, 100); 
                return;
            }
            
            // Leaflet is ready. Start the main dashboard logic.
            loadDashboard();
        }

        /**
         * Main function to coordinate data loading and map rendering.
         */
        async function loadDashboard() {
            initMap();

            try {
                statusMessage.textContent = "Fetching data: large CSV crime records and GeoJSON boundary...";
                
                // Start concurrent fetch operations
                // Note: fetchCrimeData now handles its own status updates during the parsing phase.
                const [crimeDataPoints] = await Promise.all([
                    fetchCrimeData(),
                    addGeoJsonBoundary()
                ]);
                
                if (crimeDataPoints.length === 0) {
                    statusMessage.textContent = "Error: Failed to load crime data points. Check console for network or CSV parsing errors.";
                    return;
                }
                
                addMarkerLayer(crimeDataPoints);

                // Set map bounds to fit all points
                const latLngs = crimeDataPoints.map(p => [p.lat, p.lng]);
                map.fitBounds(L.latLngBounds(latLngs), { padding: [20, 20] });

            } catch (error) {
                console.error("CRITICAL ERROR during dashboard load:", error);
                statusMessage.textContent = "CRITICAL ERROR: Initialization failed. See console (F12) for details.";
            }
        }

        // Start the process of waiting for dependencies to load
        waitForDependencies();

    </script>
</body>
</html>
